#!/usr/bin/env python

DO_3D_PLOTTING = False

RAYTRACING_BACKEND = 'cgal'
# RAYTRACING_BACKEND = 'embree'

cmap = dict()
try:
    import colorcet as cc
    cmap['jet'] = cc.cm.rainbow
    cmap['gray'] = cc.cm.gray
    cmap['fire'] = cc.cm.fire
except ImportError:
    print('failed to import colorcet: using matplotlib colormaps')
    cmap['jet'] = 'jet'
    cmap['gray'] = 'gray'
    cmap['fire'] = 'inferno'

try:
    import dmsh
    USE_DISTMESH = True
except ImportError:
    print('failed to import distmesh: will use scipy.spatial.Delaunay')
    USE_DISTMESH = False

import matplotlib.pyplot as plt
import meshio
import netCDF4
import numpy as np
import os
import pyvista as pv
import scipy.interpolate
import time

from flux.compressed_form_factors import CompressedFormFactorMatrix
from flux.model import compute_steady_state_temp
from flux.plot import plot_blocks, tripcolor_vector

RAYTRACING_BACKEND = RAYTRACING_BACKEND.lower()
if RAYTRACING_BACKEND == 'cgal':
    from flux.shape import CgalTrimeshShapeModel as MyTrimeshShapeModel, EmbreeTrimeshShapeModel
elif RAYTRACING_BACKEND == 'embree':
    from flux.shape import EmbreeTrimeshShapeModel as MyTrimeshShapeModel
else:
    raise ValueError('RAYTRACING_BACKEND should be one of: "cgal", "embree"')

if __name__ == '__main__':
    # Define constants used in the simulation:
    e0 = 3*np.pi/180 # Solar elevation angle
    F0 = 1365 # Solar constant
    emiss = 0.95 # Emissitivity
    rho = 0.12 # Visual (?) albedo
    dir_sun = np.array([0, -np.cos(e0), np.sin(e0)]) # Direction of sun
    x0, x1, y0, y1 = -35, 25, 40, 100 # Bounding box of crater (not
                                      # used except in
                                      # lunar_south_pole.png plot at
                                      # the moment)
    h = 0.25 # Desired edge lengths of triangles generated by DistMesh
    p0 = np.array([-5, 75]) # Center of circular mesh
    r0 = 25 # # Radius of circular mesh

    # use meshio to import obj shapefile
    mesh = meshio.read(
        filename="examples/haworth5412.obj",  # string, os.PathLike, or a buffer/open file
    )
    V = mesh.points
    V = V.astype(np.float32)  # embree is anyway single precision
    V = V[:, :3]
    F = mesh.cells[0].data

    # Create a triangle mesh shape model using the vertices (V) and
    # face indices (F).
    shape_model = EmbreeTrimeshShapeModel(V, F)

    # Build the compressed form factor matrix. All of the code related
    # to this can be found in the "form_factors.py" file in this
    # directory.
    t0 = time.perf_counter()
    FF = CompressedFormFactorMatrix(shape_model, tol=1e-3, min_size=512)
    print('assembled form factor matrix in %f sec (%1.2f MB)' %
          (time.perf_counter() - t0, FF.nbytes/(1024**2),))
    del t0

    # Python makes it very easy to serialize object hierarchies and
    # write them to disk as binary files. We do that here to save the
    # compressed form factor matrix. We can reload it later if we
    # want, without having to first compute it (or load an OBJ file,
    # or set up Embree, or any of that stuff).
    FF.save('FF.bin')
    print('saved compressed form factor matrix to FF.bin')

    shape_model =MyTrimeshShapeModel(V, F)

    # Compute the direct irradiance and find the elements which are
    # in shadow.
    # =============================================
    # get sub-points for extended Sun
    import pandas as pd
    extsun_coord = f"examples/coordflux_100pts_outline33_centerlast_R1_F1_stdlimbdark.txt"
    extsun_ = pd.read_csv(extsun_coord, header=None).values
    print(f"# Sun is an extended source (see {extsun_coord})...")
    print(extsun_)
    Zs = np.array([0, 0, 1])
    Us = dir_sun / np.linalg.norm(dir_sun)
    Vs = np.cross(Zs, Us)
    Ws = np.cross(Us, Vs)
    Rs = 695700.  # Sun radius, km

    sunveccs = dir_sun + Vs * extsun_[:, 0][:, np.newaxis] * Rs + Ws * extsun_[:, 1][:, np.newaxis] * Rs
    distSunkm = np.linalg.norm(sunveccs, axis=1)[:, np.newaxis]
    sundirs = sunveccs / distSunkm
    E = shape_model.get_direct_irradiance(F0 / 100., sundirs)
    E = np.sum(E, axis=1)
    #
    # E = shape_model.get_direct_irradiance(F0, dir_sun)
    I_shadow = E == 0

    # Compute the steady state temperature. This function is at the
    # top of this file.
    T = compute_steady_state_temp(FF, E, rho, emiss)
    print('computed T')

    # Finally, we make some plots showing what we just did, and write
    # them to disk:

    fig, ax = plot_blocks(FF._root)
    fig.savefig('haworth_blocks.png')
    plt.close(fig)
    print('wrote haworth_blocks.png to disk')

    fig, ax = tripcolor_vector(V, F, E, cmap=cmap['gray'])
    fig.savefig('haworth_E.png')
    plt.close(fig)
    print('wrote haworth_E.png to disk')

    fig, ax = tripcolor_vector(V, F, T, vmin=0, vmax=400, cmap=cmap['fire'])
    fig.savefig('haworth_T.png')
    plt.close(fig)
    print('wrote haworth_T.png to disk')

    fig, ax = tripcolor_vector(V, F, T, I=I_shadow, cmap=cmap['jet'])
    fig.savefig('haworth_T_shadow.png')
    plt.close(fig)
    print('wrote haworth_T_shadow.png to disk')

    # Use pyvista to make a nice 3D plot of the temperature.
    vertices = V.copy()
    faces = np.concatenate([3*np.ones((F.shape[0], 1), dtype=F.dtype), F], axis=1)
    surf = pv.PolyData(vertices, faces)
    surf.cell_arrays['T'] = T
    surf.cell_arrays['opacity'] = np.logical_not(I_shadow).astype(T.dtype)

    this_cmap = cmap['jet']

    if DO_3D_PLOTTING:
        plotter = pv.Plotter()
        plotter.add_mesh(surf, scalars='T', opacity='opacity',
                         use_transparency=True, cmap=this_cmap)
        cpos = plotter.show()

        plotter = pv.Plotter(off_screen=True)
        plotter.background_color = 'black'
        plotter.add_mesh(surf, scalars='T', opacity='opacity',
                         use_transparency=True, cmap=this_cmap)
        plotter.camera_position = cpos
        plotter.set_focus([*p0, shape_model.P[:, 2].mean()])
        plotter.screenshot('test.png')
