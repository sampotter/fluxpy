import logging
import os
import time

import numpy as np
import pygmt as pygmt
from matplotlib.path import Path

import xarray as xr
import netCDF4
import dmsh
import meshio

from src.astro_trans import sph2cart
from src.unproject_coord import unproject_stereographic

from plapp.config import FluxOpt
from plapp.import_obj import import_obj
from plapp.select_roi import create_shape_on_image

def save_mesh(V,F,objname):
    # Let's use another Python library (meshio) to save the triangle
    # mesh generated by Distmesh as an OBJ file.
    # TODO possible to save other info (resolution, num_faces)?
    points = V
    cells = [('triangle', F)]
    num_faces = F.shape[0]
    mesh = meshio.Mesh(points, cells)
    mesh_path = os.path.join(FluxOpt.get("example_dir"), FluxOpt.get("body"), f'{objname}.obj')
    print(mesh_path)
    mesh.write(mesh_path)
    print(f'wrote {mesh_path} to disk')

    return  mesh_path

# TODO clean-up arguments (or use them... e.g., crater should be used for circular RoI selection)
def grd2obj(grdfile,name='feature',crater=True,h=0.9,USE_DISTMESH=False):

    # TODO give region as input (for repeated tests)
    use_predef_region = False
    use_netcdf_reader = True
    recompute_mesh_for_full_region = True

    # First, load the DEM of the lunar south pole, which is stored as
    if use_netcdf_reader:
        # a netCDF4 file, and pull out the coordinate data.
        path = grdfile

        # read input topography
        rootgrp = netCDF4.Dataset(path)
        z_stereo = np.array(rootgrp['z']).astype(np.float64)
        init_shape = z_stereo.shape
        # convert polar stereo to planetocentric cartesian (xyz of whole map)
        x_tot, y_tot, z_tot = netcdf_to_cart(rootgrp, lat0=-90, R=1737.4)
    else: # it should be possible to read grdfiles via xarray or GeoPandas,
        # but I need to fix this
        ds = xr.open_dataset(grdfile)
        # ds.to_array(dim='z').plot.imshow()
        z_stereo = ds.data_vars['z']
        init_shape = z_stereo.shape
        df = ds.to_dataframe()

        df = df.reset_index()
        df['lon'], df['lat'] = unproject_stereographic(x=df.x, y=df.y, lon0=0., lat0=-90., R=1737.4)
        x_tot, y_tot, z_tot = sph2cart(r=df.z + 1737.4, lat=df.lat, lon=df.lon)
        x_tot = x_tot.values.reshape(init_shape)#[1:,:]
        y_tot = y_tot.values.reshape(init_shape)#[1:,:]
        z_tot = z_tot.values.reshape(init_shape)#[::1,::1]

    if not use_predef_region:
        # locate region on image
        shapes = create_shape_on_image((np.arange(len(z_stereo)), np.arange(len(z_stereo)), z_stereo),close_prec=100)[0]
        # print(shapes)
        i0, i1 = np.min(shapes[:, 1]), np.max(shapes[:, 1])
        j0, j1 = np.min(shapes[:, 0]), np.max(shapes[:, 0])
    else:
        i0, i1, j0, j1 = 599, 840, 574, 827 # 922, 1882, 443, 1473

    print(f"Selected region has indexes: xmin={i0}, xmax={i1}, ymin={j0}, ymax={j1}")

    # Generate mesh for the whole grd, based on cartesian map
    # -------------------------------------------------------
    # TODO the mesh could have decreasing resolution away from the selected region (speed-up)
    start_int_mesh = time.time()

    # get minmax xy indexes
    x0, x1, y0, y1 = min(x_tot.ravel()), max(x_tot.ravel()), min(y_tot.ravel()), max(y_tot.ravel())
    # generate triangle mesh within map-defined rectangle
    geo = dmsh.Rectangle(x0,x1,y0,y1)

    if recompute_mesh_for_full_region:
        logging.info(f"Preparing global mesh of area covered by {grdfile} (for occultations)...")
        # get points (V) and cells (F) with side-length h
        V_glb, F_glb = dmsh.generate(geo, h)

        end_int_mesh = time.time()
        print(f"Global mesh generated in {end_int_mesh - start_int_mesh} seconds.")
        # plot mesh
        # dmsh.helpers.show(V, F, geo)

        # interpolate the whole map at points V: V[2D] --> V[3D]
        # TODO better options for interpolation? It takes ~1 min for lunar_south_pole_80mpp_curvature.grd
        X = V_glb[:, 0]
        Y = V_glb[:, 1]
        Z = interp_map(x_tot, y_tot, z_tot, X, Y)
        V_glb = np.row_stack([X, Y, Z]).T
    else:
        V_glb, F_glb, N_glb = import_obj(
            obj_path=f"/home/sberton2/Works/NASA/radiosity/py-flux-app/examples/MOON/haworth_glb.obj", get_normals=True)

    # get 3D inner mesh
    # select points V within the selected region from global mesh, then recell F
    # -----------------
    logging.info(f"Cutting out mesh of selected area (for flux computations)...")
    # define rectangle of region selected by hand
    print(x_tot.shape,y_tot.shape)
    x_ = x_tot[i0:i1, j0:j1]
    y_ = y_tot[i0:i1, j0:j1]

    # fig,ax=plt.subplots()
    # ax.scatter(x=y_tot,y=x_tot)
    # ax.scatter(x=V_glb[:, 1],y=V_glb[:, 0])
    xx1, xx0, yy1, yy0 = max(x_.ravel()),min(x_.ravel()),max(y_.ravel()),min(y_.ravel())
    rectangle_selection = np.array([[xx0, yy0], [xx1, yy0], [xx1, yy1], [xx0, yy1]])

    # use rectangle.contains_points on V to select only points falling within
    p = Path(rectangle_selection)  # make a polygon (rectangle in this case)
    print(p)
    mask = p.contains_points(V_glb[:,:2])
    # extract V and F of inner mesh from global mesh
    V_int = V_glb[mask,:]
    # ax.scatter(x=V_int[:, 1],y=V_int[:, 0],c=V_int[:, 2])
    # plt.show()
    F_int = dmsh.main._recell(V_int[:,:2],geo)
    # plot inner mesh
    # dmsh.helpers.show(V_int[:,:2], F_int, geo)

    # Save output and print some interesting indicators
    # -------------------------------------------------
    num_faces = F_glb.shape[0]
    print('created total mesh with %d triangles' % num_faces)
    num_faces_inner = F_int.shape[0]
    print('created inner mesh with %d triangles' % num_faces_inner)

    # Save the mesh data to disk as numpy binary files
    mesh_path = save_mesh(objname=name, V=V_int, F=F_int)
    ext_mesh_path = save_mesh(objname=f"{name}_ext", V=V_glb, F=F_glb)

    return  mesh_path, ext_mesh_path

def netcdf_to_cart(rootgrp, lon0=0, lat0=-90, R = 1737.4):

    # get stereo projection xyz from grid
    grdx = np.array(rootgrp['x'])
    grdy = np.array(rootgrp['y'])[1:]
    grdz_ = np.array(rootgrp['z']).astype(np.float64)[1:,:]

    grdz_ = grdz_.T  # TODO: why is this necessary?
    del rootgrp
    grdx_, grdy_ = np.meshgrid(grdx, grdy)

    # Unproject from stereographic to lon/lat
    rho = np.sqrt(grdx_ ** 2 + grdy_ ** 2)
    c = 2 * np.arctan2(rho, 2 * R)
    lat_ = np.rad2deg(
        np.arcsin(np.cos(c) * np.sin(np.deg2rad(lat0)) +
                  (np.cos(np.deg2rad(lat0)) * np.sin(c) * grdy_) / rho))
    lon_ = np.mod(
        lon0 + np.rad2deg(
            np.arctan2(
                grdx_ * np.sin(c),
                np.cos(np.deg2rad(lat0)) * rho * np.cos(c)
                - np.sin(np.deg2rad(lat0)) * grdy_ * np.sin(c))),
        360)
    lat_[(grdx_ == 0) & (grdy_ == 0)] = lat0
    lon_[(grdx_ == 0) & (grdy_ == 0)] = lon0

    # Go from lon/lat to cartesian (planetocentric)
    az_ = np.deg2rad(lon_)
    el_ = np.deg2rad(lat_)
    r_ = R + grdz_

    x_ = r_ * np.cos(az_) * np.cos(el_)
    y_ = r_ * np.sin(az_) * np.cos(el_)
    z_ = r_ * np.sin(el_)

    # print(x_.shape,y_.shape,z_.shape)
    # exit()

    return x_, y_, z_

def interp_map(x_tot, y_tot, z_tot, X, Y):
    from scipy.interpolate import griddata

    # interpolate topo to get Z at X,Y points (mesh points V)
    start_interp = time.time()
    Z = griddata(np.vstack([x_tot.ravel(), y_tot.ravel()]).T, z_tot.ravel(), (X, Y), method='cubic')
    end_interp = time.time()
    print("Input elevation map interpolated to mesh after", end_interp - start_interp, "seconds.")
    return Z

if __name__ == '__main__':

    grd2obj(grdfile=os.path.join('.', 'lunar_south_pole_80mpp_curvature.grd'),
            name='haworth',
            distant_topo=True)